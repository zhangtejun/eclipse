<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
	content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="format-detection" content="telephone=no">
<!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->
<title>首页</title>
<script src="js/jquery.min.js"></script>
<!-- 新 Bootstrap 核心 CSS 文件 -->
<link rel="stylesheet"
	href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
<!-- 可选的Bootstrap主题文件（一般不用引入） -->
<link rel="stylesheet"
	href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
<!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
<!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
<script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
</head>
<body>
	<div>
		<strong id="zht">prototype</strong>
	</div>
	<div id="zht1">
		<p>
			<strong>函数：原型</strong>
		</p>
		<p>
			每一个构造函数都有一个属性叫做原型(prototype,下面都不再翻译，使用其原文)。这个属性非常有用：为一个特定类声明通用的变量或者函数。</p>
		<p>
			<strong><em>prototype的定义</em></strong>
		</p>
		<p>你不需要显式地声明一个prototype属性，因为在每一个构造函数中都有它的存在。你可以看看下面的例子：</p>
		<p>
			<strong>Example PT1</strong>
		</p>
		<p>
			<strong>CODE:</strong><br> <span><pre color="#000000">function Test()<br> {<br> }<br> alert(Test.prototype); // 输出 "Object"</pre></span>
		</p>
		<p>
			<strong><em>给prototype添加属性</em></strong>
		</p>
		<p>
			就如你在上面所看到的，prototype是一个对象，因此，你能够给它添加属性。你添加给prototype的属性将会成为使用这个构造函数创建的对象的通用属性。</p>
		<p>
			例如，我下面有一个数据类型Fish，我想让所有的鱼都有这些属性：livesIn="water"和price=20；为了实现这个，我可以给构造函数Fish的prototype添加那些属性。</p>
		<p>
			<strong>Example PT2</strong>
		</p>
		<p>
			<strong>CODE:</strong><br> <span><pre color="#000000">function Fish(name, color)<br> {<br> this.name=name;<br> this.color=color;<br> }<br> Fish.prototype.livesIn="water";<br> Fish.prototype.price=20;</pre></span>
		</p>
		<p>接下来让我们作几条鱼：</p>
		<p>
			<strong>CODE:</strong><br> <span><pre color="#000000">var fish1=new Fish("mackarel", "gray");<br> var fish2=new Fish("goldfish", "orange");<br> var fish3=new Fish("salmon", "white");</pre></span>
		</p>
		<p>再来看看鱼都有哪些属性：</p>
		<p>
			<strong>CODE:</strong><br> <span><pre color="#000000">for (int i=1; i&lt;=3; i++)<br> {<br> var fish=eval_r("fish"+i);&nbsp;<wbr>&nbsp;<wbr> // 我只是取得指向这条鱼的指针<br> alert(fish.name+","+fish.color+","+fish.livesIn+","+fish.price);<br> }</pre></span>
		</p>
		<p>输出应该是：</p>
		<p>
			<strong>CODE:</strong><br> <pre color="#000000"><span>"mackarel, gray, water,20"<br> "goldfish, orange, water, 20"<br> "salmon, white,water, 20"
			</span>
		</pre>
		</p>
		 
   <p> 你看到所有的鱼都有属性livesIn和price,我们甚至都没有为每一条不同的鱼特别声明这些属性。这时因为当一个对象被创建时，这个构造函数 将会把它的属性prototype赋给新对象的内部属性__proto__。这个__proto__被这个对象用来查找它的属性。</p> 
   <p> 你也可以通过prototype来给所有对象添加共用的函数。这有一个好处：你不需要每次在构造一个对象的时候创建并初始化这个函数。为了解释这一点，让我们重新来看Example DT9并使用prototype来重写它：</p> 
   <p>
				<strong><em>用prototype给对象添加函数</em></strong>
			</p> 
   <p>
				<strong>Example PT3</strong>
			</p> 
   <p>
				<strong>CODE:</strong>
			</p> 
   <pre>function Employee(name, salary)<br> {<br> this.name=name;&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
				<br> this.salary=salary;<br> }<br> Employee.prototype.getSalary=function getSalaryFunction()<br> {<br> return this.salary;<br> } 
   Employee.prototype.addSalary=function addSalaryFunction(addition)<br> {<br> this.salary=this.salary+addition;<br> }</pre> 
   <p>&nbsp;<wbr>
			</p> 
   <p>我们可以象通常那样创建对象：</p> 
   <p>
				<strong>CODE:</strong><br> <span><pre color="#000000">var boss1=new Employee("Joan", 200000);<br> var boss2=new Employee("Kim", 100000);<br> var boss3=new Employee("Sam", 150000);</pre></span>
			</p> 
   <p>并验证它：</p> 
   <p>
				<strong>CODE:</strong><br> <span><pre color="#000000">alert(boss1.getSalary());&nbsp;<wbr>&nbsp;<wbr> // 输出 200000<br> alert(boss2.getSalary());&nbsp;<wbr>&nbsp;<wbr> // 输出 100000<br> alert(boss3.getSalary());&nbsp;<wbr>&nbsp;<wbr> // 输出 150000</pre></span>
			</p> 
   <p>这里有一个图示来说明prototype是如何工作的。这个对象的每一个实例(boss1, boss2, boss3)都有一个内部属性叫做__proto__，这个属性指向了它的构造器(Employee)的属性prototype。当你执行 getSalary或者addSalary的时候，这个对象会在它的__proto__找到并执行这个代码。注意这点：这里并没有代码的复制(和 Example DT8的图表作一下对比)。</p> 
   <p align="center">
				<img src="http://www.blueidea.com/articleimg/2006/07/3823/05.gif"
					real_src="http://www.blueidea.com/articleimg/2006/07/3823/05.gif"
					border="0" height="240" width="490"
					alt="js的Prototype属性&nbsp;<wbr>解释及常用方法"
					title="js的Prototype属性&nbsp;<wbr>解释及常用方法">
			</p>
  
	</div>
	<div id="zht1">
		<p>JS中的phototype是JS中比较难理解的一个部分</p>

		<p>本文基于下面几个知识点:</p>

		<p>
			<span style="font-size: 14pt;">1 原型法设计模式</span>
		</p>
		<p>在.Net中可以使用clone()来实现原型法</p>
		<p>原型法的主要思想是，现在有1个类A,我想要创建一个类B,这个类是以A为原型的,并且能进行扩展。我们称B的原型为A。</p>

		<p>
			<span style="font-size: 14pt;">2 javascript的方法可以分为三类：</span>
		</p>
		<p>a 类方法</p>
		<p>b 对象方法</p>
		<p>c 原型方法</p>
		<p>例子：</p>
		<div class="cnblogs_Highlighter">
			<div class="cnblogs_Highlighter">
				<pre class="cnblogs_code"> 
function People(name)
{
  this.name=name;
  //对象方法
  this.Introduce=function(){
    alert("My name is "+this.name);
  }
}
//类方法
People.Run=function(){
  alert("I can run");
}
//原型方法
People.prototype.IntroduceChinese=function(){
  alert("我的名字是"+this.name);
}
//测试
var p1=new People("Windking");

p1.Introduce();

People.Run();

p1.IntroduceChinese();
     </pre>
				<p>&nbsp;</p>
				<p>
					<span style="font-size: 14pt;">3 obj1.func.call(obj)方法 </span>
				</p>
				<p>意思是将obj看成obj1,调用func方法</p>
				<p>&nbsp;</p>

				<p>好了，下面一个一个问题解决：</p>

				<p>
					<span style="font-size: 14pt;">prototype是什么含义？ </span>
				</p>

				<p>javascript中的每个对象都有prototype属性，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。
				</p>
				<p>A.prototype = new B();</p>
				<p>理解prototype不应把它和继承混淆。A的prototype为B的一个实例，可以理解A将B中的方法和属性全部克隆了一遍。A能使用B的方法和属性。这里强调的是克隆而不是继承。可以出现这种情况：A的prototype是B的实例，同时B的prototype也是A的实例。
				</p>
				<p>&nbsp;</p>
				<p>先看一个实验的例子：</p>
				<br>
				<pre class="cnblogs_code"> 
function baseClass()
{
  this.showMsg = function()
  {
     alert("baseClass::showMsg");   
  }
}
function extendClass()
{
}
extendClass.prototype = new baseClass();
var instance = new extendClass();
instance.showMsg(); // 显示baseClass::showMsg
			</pre>
			<p>我们首先定义了baseClass类，然后我们要定义extentClass，但是我们打算以baseClass的一个实例为原型，来克隆的extendClass也同时包含showMsg这个对象方法。</p>
			<p>extendClass.prototype = new
				baseClass()就可以阅读为：extendClass是以baseClass的一个实例为原型克隆创建的。</p>

			<p>
				那么就会有一个问题，<span style="font-size: 14pt;">如果extendClass中本身包含有一个与baseClass的方法同名的方法会怎么样？</span>
			</p>
			<p>下面是扩展实验2：</p>
			<br>
			<pre class="cnblogs_code"> 
function baseClass()
{
    this.showMsg = function()
    {
        alert("baseClass::showMsg");   
    }
}
function extendClass()
{
    this.showMsg =function ()
    {
        alert("extendClass::showMsg");
    }
}
extendClass.prototype = new baseClass();
var instance = new extendClass();
instance.showMsg();//显示extendClass::showMsg
    </pre>
			<p>实验证明：函数运行时会先去本体的函数中去找，如果找到则运行，找不到则去prototype中寻找函数。或者可以理解为prototype不会克隆同名函数。</p>

			<p>那么又会有一个新的问题：</p>
			<p>
				<span style="font-size: 14pt;">如果我想使用extendClass的一个实例instance调用baseClass的对象方法showMsg怎么办？</span>
			</p>

			<p>答案是可以使用call:</p>
			<br>
			<pre class="cnblogs_code"> 
extendClass.prototype = new baseClass();
var instance = new extendClass();
var baseinstance = new baseClass();
baseinstance.showMsg.call(instance);//显示baseClass::showMsg
    </pre>

			<p>这里的baseinstance.showMsg.call(instance);阅读为“将instance当做baseinstance来调用，调用它的对象方法showMsg”</p>
			<p>好了，这里可能有人会问，为什么不用baseClass.showMsg.call(instance);</p>
			<p>这就是对象方法和类方法的区别，我们想调用的是baseClass的对象方法</p>

			<p>
				<span style="font-size: 14pt;">最后，下面这个代码如果理解清晰，那么这篇文章说的就已经理解了：</span>
			</p>

			<br>
			<pre class="cnblogs_code"> 
function baseClass()
{
    this.showMsg = function()
    {
        alert("baseClass::showMsg");   
    }
   
    this.baseShowMsg = function()
    {
        alert("baseClass::baseShowMsg");
    }
}
baseClass.showMsg = function()
{
    alert("baseClass::showMsg static");
}

function extendClass()
{
    this.showMsg =function ()
    {
        alert("extendClass::showMsg");
    }
}
extendClass.showMsg = function()
{
    alert("extendClass::showMsg static")
}

extendClass.prototype = new baseClass();
var instance = new extendClass();

instance.showMsg(); //显示extendClass::showMsg
instance.baseShowMsg(); //显示baseClass::baseShowMsg
instance.showMsg(); //显示extendClass::showMsg

baseClass.showMsg.call(instance);//显示baseClass::showMsg static

var baseinstance = new baseClass();
baseinstance.showMsg.call(instance);//显示baseClass::showMsg

    </pre>

		</div>
	</div>
	<script type="text/javascript">
		/*
		 * 我们设置2个盒子一个限制最小高度，一个设置限制最大高度，最小高度限制的对象如果内容不多不会超出限制最小高度，此时对象会显示最小高度限制值，如果内容比较多超过了最小高度限制能装下单，此时对象会自动增高。而后者最大高度max-height限制，内容少时候不会有什么区别，但内容多时候，而最大高度限制也装不下时候，内容会超出最大高度限制，但对象本身还是最大高度，这样就出现内容溢出超出对象盒子，我们即可使用css overflow属性隐藏溢出内容。
		 */
		// 计算页面的实际高度，iframe自适应会用到
		function calcPageHeight(doc) {
			var cHeight = Math.max(doc.body.clientHeight,
					doc.documentElement.clientHeight)
			var sHeight = Math.max(doc.body.scrollHeight,
					doc.documentElement.scrollHeight)
			var height = Math.max(cHeight, sHeight)
			return height
		}
		window.onload = function() {
			debugger
			var height = calcPageHeight(document)
			parent.$("#iframe").css("min-height", height + 'px');
			//         parent.document.getElementById('iframe').style.(max-height) = height + 'px'     
		}
		window.parent.$("#title").html($("#zht").html());
	</script>
</body>
</html>